<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Timeline SVG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #FAF9FA;
            padding: 40px;
            color: #373737;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #6F02FD;
            font-size: 48px;
            font-weight: 300;
            margin-bottom: 40px;
        }

        .upload-section {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 40px;
        }

        .upload-area {
            border: 2px dashed #6F02FD;
            border-radius: 8px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #2C0165;
            background: #f5f3ff;
        }

        .upload-area.drag-over {
            border-color: #2C0165;
            background: #e8e0ff;
        }

        .upload-input {
            display: none;
        }

        .upload-text {
            font-size: 20px;
            color: #373737;
            margin-bottom: 10px;
        }

        .upload-subtext {
            font-size: 14px;
            color: #666;
        }

        .controls-section {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 40px;
            display: none;
        }

        .controls-section.active {
            display: block;
        }

        .control-group {
            margin-bottom: 30px;
        }

        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #373737;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-item {
            flex: 1;
        }

        .date-inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .date-input {
            flex: 1;
        }

        .date-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .dimension-inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .dimension-input {
            flex: 1;
        }

        .dimension-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .toggle-buttons {
            display: flex;
            gap: 5px;
            background: #f0f0f0;
            padding: 3px;
            border-radius: 6px;
            overflow: hidden;
        }

        .toggle-button {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .toggle-button.active {
            background: #6F02FD;
            color: white;
        }

        .button {
            padding: 12px 24px;
            background: #6F02FD;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            margin-right: 10px;
        }

        .button:hover {
            background: #2C0165;
        }

        .button.secondary {
            background: #3570DF;
        }

        .button.secondary:hover {
            background: #2C0165;
        }

        .preview-section {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: none;
            overflow-x: auto;
        }

        .preview-section.active {
            display: block;
        }

        .preview-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
        }

        #svgPreview {
            max-width: 100%;
            height: auto;
        }

        .project-selector {
            margin-bottom: 20px;
        }

        .project-selector label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #373737;
        }

        .project-selector select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .info-message {
            background: #e8e0ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            color: #2C0165;
        }

        select, input[type="date"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }

        .stage-order-item {
            background: #f5f5f5;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .stage-order-item:hover {
            background: #e8e0ff;
        }

        .stage-order-item.dragging {
            opacity: 0.5;
        }

        .drag-handle {
            color: #666;
            margin-right: 10px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Gerador de Timeline SVG</h1>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" class="upload-input" accept=".csv">
                <div class="upload-text">Arraste o arquivo CSV aqui</div>
                <div class="upload-subtext">ou clique para selecionar</div>
            </div>
        </div>

        <div class="controls-section" id="controlsSection">
            <div class="info-message">
                ℹ️ O SVG será otimizado para importação no Figma, com grupos nomeados e estrutura editável.
            </div>

            <div class="control-group">
                <div class="project-selector">
                    <label>Selecione o Projeto:</label>
                    <select id="projectSelector" onchange="filterByProject()">
                        <option value="all">Todos os Projetos</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Período do Cronograma</label>
                <div class="date-inputs">
                    <div class="date-input">
                        <label>Data Inicial:</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="date-input">
                        <label>Data Final:</label>
                        <input type="date" id="endDate">
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Ordem das Etapas</label>
                <div id="stageOrderContainer" style="display: none;">
                    <div id="stageOrderList"></div>
                    <button type="button" class="button secondary" onclick="resetStageOrder()">Restaurar Ordem Original</button>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Configurações de Exibição</label>
                <div class="control-row">
                    <div class="control-item">
                        <label>Níveis de Tempo:</label>
                        <select id="timeLevels" onchange="updateTimeLevels()">
                            <option value="year-month">Anos e Meses</option>
                            <option value="month-week" selected>Meses e Semanas</option>
                            <option value="week-day">Semanas e Dias</option>
                        </select>
                    </div>
                    <div class="control-item">
                        <div class="checkbox-group">
                            <input type="checkbox" id="includeWeekends" onchange="updateWeekendSetting()">
                            <label for="includeWeekends">Incluir finais de semana</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Dimensões do SVG</label>
                <div class="dimension-inputs">
                    <div class="dimension-input">
                        <label>Largura (px):</label>
                        <input type="number" id="svgWidth" value="1920" min="800" max="4000">
                    </div>
                    <div class="dimension-input">
                        <label>Altura da barra (px):</label>
                        <input type="number" id="barHeight" value="28" min="20" max="80">
                    </div>
                    <div class="dimension-input">
                        <label>Largura da área de tarefas (px):</label>
                        <input type="number" id="taskAreaWidth" value="300" min="200" max="600">
                    </div>
                </div>
            </div>

            <button class="button" onclick="generateSVG()">Gerar SVG</button>
            <button class="button secondary" onclick="downloadSVG()">Baixar SVG</button>
            <button class="button secondary" onclick="resetAll()">Novo Arquivo</button>
        </div>

        <div class="preview-section" id="previewSection">
            <h2>Preview do SVG</h2>
            <div class="preview-container" id="svgContainer"></div>
        </div>
    </div>

    <script>
        // Variáveis globais
        let csvData = [];
        let processedData = [];
        let allProjects = [];
        let currentProject = 'all';
        let svgContent = '';
        let timeLevels = 'month-week';
        let includeWeekends = false;
        let stageOrder = [];
        let colorPalette = ['#6F02FD', '#2C0165', '#6CDADE', '#3570DF', '#EDFF19', '#FFA4E8'];
        let groupColors = {};

        // Configurar upload
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Processar arquivo
        function handleFile(file) {
            if (!file.name.endsWith('.csv')) {
                alert('Por favor, selecione um arquivo CSV');
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    csvData = results.data;
                    processCSVData();
                },
                error: function(error) {
                    alert('Erro ao ler o arquivo: ' + error.message);
                }
            });
        }

        // Processar dados do CSV
        function processCSVData() {
            // Filtrar tarefas válidas
            const validTasks = csvData.filter(row => {
                return row['Due Date'] && row.Task;
            });

            if (validTasks.length === 0) {
                alert('Nenhuma tarefa válida encontrada no arquivo');
                return;
            }

            // Identificar todos os projetos únicos
            allProjects = [...new Set(validTasks.map(task => task.Project || 'Sem Projeto'))];
            
            // Atualizar o seletor de projetos
            const projectSelector = document.getElementById('projectSelector');
            projectSelector.innerHTML = '<option value="all">Todos os Projetos</option>';
            allProjects.forEach(project => {
                const option = document.createElement('option');
                option.value = project;
                option.textContent = project;
                projectSelector.appendChild(option);
            });

            // Processar dados inicialmente com todos os projetos
            processProjectData(validTasks);

            // Mostrar controles
            document.getElementById('controlsSection').classList.add('active');
        }

        // Processar dados de acordo com o projeto selecionado
        function processProjectData(tasks) {
            // Filtrar por projeto se necessário
            let filteredTasks = tasks;
            if (currentProject !== 'all') {
                filteredTasks = tasks.filter(task => task.Project === currentProject);
            }

            // Calcular período
            let allDates = [];
            filteredTasks.forEach(task => {
                const dueDate = new Date(task['Due Date']);
                let startDate = task.Start ? new Date(task.Start) : null;
                
                if (!startDate || isNaN(startDate)) {
                    startDate = new Date(dueDate);
                    startDate.setDate(startDate.getDate() - 7);
                }
                
                allDates.push(startDate, dueDate);
            });

            const minDate = new Date(Math.min(...allDates));
            const maxDate = new Date(Math.max(...allDates));
            
            // Ajustar para início e fim de período baseado no nível
            const adjustedDates = adjustDateRange(minDate, maxDate);
            
            // Atualizar inputs
            document.getElementById('startDate').value = adjustedDates.start.toISOString().split('T')[0];
            document.getElementById('endDate').value = adjustedDates.end.toISOString().split('T')[0];

            // Processar e organizar dados
            processedData = organizeData(filteredTasks);
            
            // Criar interface de ordenação de etapas
            createStageOrderInterface();
        }

        // Ajustar range de datas baseado no nível
        function adjustDateRange(minDate, maxDate) {
            const start = new Date(minDate);
            const end = new Date(maxDate);

            switch (timeLevels) {
                case 'year-month':
                    // Ajustar para início/fim do ano
                    start.setMonth(0, 1);
                    end.setFullYear(end.getFullYear() + 1, 0, 0);
                    break;
                case 'month-week':
                    // Ajustar para início/fim do mês
                    start.setDate(1);
                    end.setMonth(end.getMonth() + 1, 0);
                    break;
                case 'week-day':
                    // Ajustar para início/fim da semana
                    start.setDate(start.getDate() - start.getDay() + 1);
                    end.setDate(end.getDate() + (7 - end.getDay()));
                    break;
            }

            // Adicionar margem
            start.setDate(start.getDate() - 7);
            end.setDate(end.getDate() + 7);

            return { start, end };
        }

        // Filtrar por projeto
        function filterByProject() {
            const selector = document.getElementById('projectSelector');
            currentProject = selector.value;
            
            // Reprocessar dados com o filtro
            const validTasks = csvData.filter(row => {
                return row['Due Date'] && row.Task;
            });
            
            processProjectData(validTasks);
        }

        // Atualizar configuração de níveis de tempo
        function updateTimeLevels() {
            timeLevels = document.getElementById('timeLevels').value;
            // Reprocessar dados se já existirem
            if (csvData.length > 0) {
                const validTasks = csvData.filter(row => row['Due Date'] && row.Task);
                processProjectData(validTasks);
            }
        }

        // Atualizar configuração de finais de semana
        function updateWeekendSetting() {
            includeWeekends = document.getElementById('includeWeekends').checked;
        }

        // Organizar dados por grupo e projeto
        function organizeData(tasks) {
            const organized = {};
            
            tasks.forEach(task => {
                const stage = task['Project Stage'] || 'Sem Estágio';
                
                if (!organized[stage]) {
                    organized[stage] = {
                        name: stage,
                        tasks: []
                    };
                }
                
                // Processar datas
                const dueDate = new Date(task['Due Date']);
                let startDate = task.Start ? new Date(task.Start) : null;
                
                if (!startDate || isNaN(startDate)) {
                    startDate = new Date(dueDate);
                    startDate.setDate(startDate.getDate() - 7);
                }
                
                organized[stage].tasks.push({
                    name: task.Task,
                    start: startDate,
                    end: dueDate,
                    assignee: task.Assignee,
                    status: task.Status,
                    completed: task.Completed === true || task.Completed === 'TRUE',
                    effort: task.Effort
                });
            });

            // Ordenar tarefas por data de início dentro de cada etapa
            Object.values(organized).forEach(stage => {
                stage.tasks.sort((a, b) => a.start - b.start);
            });

            // Atribuir cores às etapas
            let colorIndex = 0;
            Object.keys(organized).forEach(stageKey => {
                groupColors[stageKey] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            });

            return organized;
        }

        // Gerar dias úteis (sem finais de semana se configurado)
        function generateWorkingDays(startDate, endDate) {
            const days = [];
            const currentDate = new Date(startDate);
            
            while (currentDate <= endDate) {
                const dayOfWeek = currentDate.getDay();
                
                if (includeWeekends || (dayOfWeek !== 0 && dayOfWeek !== 6)) {
                    days.push(new Date(currentDate));
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            return days;
        }

        // Gerar SVG
        function generateSVG() {
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const svgWidth = parseInt(document.getElementById('svgWidth').value);
            const barHeight = parseInt(document.getElementById('barHeight').value);
            const taskAreaWidth = parseInt(document.getElementById('taskAreaWidth').value);
            
            // Gerar dias úteis baseado na configuração
            const workingDays = generateWorkingDays(startDate, endDate);
            const totalDays = workingDays.length;
            const dayWidth = (svgWidth - taskAreaWidth) / totalDays;
            
            // Calcular altura total
            let totalTasks = 0;
            Object.values(processedData).forEach(stage => {
                totalTasks += stage.tasks.length;
            });
            
            const headerHeight = 100;
            const groupSpacing = 40;
            const taskSpacing = 2;
            
            // Calcular altura total incluindo listas de tarefas
            let totalHeight = headerHeight;
            Object.values(processedData).forEach(stage => {
                totalHeight += 30; // Título da etapa
                // Altura fixa para cada tarefa
                totalHeight += stage.tasks.length * (barHeight + taskSpacing);
                totalHeight += groupSpacing;
            });
            const svgHeight = totalHeight + 50;
            
            // Iniciar SVG
            let svg = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
            
            // Adicionar definições
            svg += '<defs>';
            // ClipPath para texto das tarefas
            svg += `<clipPath id="taskTextClip">
                      <rect x="10" y="0" width="${taskAreaWidth - 20}" height="${svgHeight}"/>
                    </clipPath>`;
            svg += '</defs>';
            
            // Background
            svg += `<rect width="${svgWidth}" height="${svgHeight}" fill="#FAF9FA"/>`;
            
            // Desenhar calendário
            svg += '<g id="calendario">';
            svg += drawTimeHeaders(workingDays, svgWidth, taskAreaWidth, dayWidth);
            svg += '</g>';
            
            // Barras de fundo (linhas de grade baseadas no segundo nível)
            svg += '<g id="background_bars">';
            svg += drawBackgroundBars(workingDays, svgWidth, taskAreaWidth, dayWidth, svgHeight, headerHeight);
            svg += '</g>';
            
            // Desenhar tarefas na ordem definida pelo usuário
            let yOffset = headerHeight;
            const orderedStages = getOrderedStages();
            
            orderedStages.forEach(([stageKey, stage]) => {
                svg += `<g id="stage_${sanitizeId(stageKey)}">`;
                
                // Título da etapa
                svg += `<text x="20" y="${yOffset}" font-family="Inter, Arial, sans-serif" font-size="16" font-weight="bold" fill="#373737">${stage.name}</text>`;
                yOffset += 20;
                
                // Lista de tarefas à esquerda (texto completo com clipping e barras de fundo)
                const barsStartY = yOffset;
                svg += `<g id="task_list_${sanitizeId(stageKey)}" clip-path="url(#taskTextClip)">`;
                
                let currentTaskY = barsStartY;
                stage.tasks.forEach((task, index) => {
                    // Usar altura fixa baseada na altura da barra
                    const taskHeight = barHeight;
                    
                    // Barra de fundo para a tarefa na lista
                    const bgColor = groupColors[stageKey];
                    // Determinar cor do texto baseada no contraste
                    const textColor = getContrastColor(bgColor);
                    
                    svg += `<rect x="10" y="${currentTaskY}" width="${taskAreaWidth - 20}" height="${barHeight}" 
                            fill="${bgColor}" rx="4" ry="4"/>`;
                    
                    // Texto completo em uma linha (será cortado pelo clip-path)
                    const textY = currentTaskY + (taskHeight / 2) + 6;
                    svg += `<text x="${taskAreaWidth - 15}" y="${textY}" font-family="Inter, Arial, sans-serif" font-size="13" fill="${textColor}" text-anchor="end">`;
                    svg += task.name; // Texto completo, sem quebra
                    svg += '</text>';
                    
                    currentTaskY += taskHeight + taskSpacing;
                });
                svg += '</g>';
                
                // Desenhar barras das tarefas
                currentTaskY = barsStartY;
                stage.tasks.forEach((task, index) => {
                    // Usar altura fixa
                    const taskHeight = barHeight;
                    
                    const taskStartX = taskAreaWidth + calculateX(task.start, workingDays, dayWidth);
                    const taskEndX = taskAreaWidth + calculateX(task.end, workingDays, dayWidth);
                    const taskWidth = Math.max(taskEndX - taskStartX, dayWidth); // Mínimo de 1 dia
                    
                    svg += `<g id="task_bar_${sanitizeId(task.name)}_${index}">`;
                    
                    // Barra da tarefa
                    const opacity = task.completed ? 0.4 : 1;
                    svg += `<rect x="${taskStartX}" y="${currentTaskY}" width="${taskWidth}" height="${barHeight}" 
                            fill="${groupColors[stageKey]}" opacity="${opacity}" rx="4" ry="4"/>`;
                    
                    // Metadata como atributos (para uso no Figma)
                    svg += `<!-- Task: ${task.name}, Start: ${task.start.toISOString().split('T')[0]}, End: ${task.end.toISOString().split('T')[0]} -->`;
                    
                    svg += '</g>';
                    currentTaskY += taskHeight + taskSpacing;
                });
                
                svg += '</g>';
                yOffset = currentTaskY + groupSpacing;
            });
            
            svg += '</svg>';
            
            svgContent = svg;
            displayPreview();
        }

        // Desenhar barras de fundo (linhas de grade baseadas no segundo nível)
        function drawBackgroundBars(workingDays, width, leftMargin, dayWidth, svgHeight, headerHeight) {
            let svg = '';
            
            if (timeLevels === 'year-month') {
                // Agrupar por meses para barras de fundo
                const months = {};
                workingDays.forEach((day, index) => {
                    const monthKey = `${day.getFullYear()}-${day.getMonth()}`;
                    if (!months[monthKey]) months[monthKey] = [];
                    months[monthKey].push({ day, index });
                });
                
                Object.entries(months).forEach(([monthKey, days]) => {
                    const startX = leftMargin + (days[0].index * dayWidth);
                    const barWidth = days.length * dayWidth;
                    
                    svg += `<rect x="${startX}" y="${headerHeight}" width="${barWidth}" height="${svgHeight - headerHeight}" 
                            fill="#f8f8f8" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                });
                
            } else if (timeLevels === 'month-week') {
                // Agrupar por semanas para barras de fundo
                const weeks = {};
                workingDays.forEach((day, index) => {
                    const weekStart = getWeekStart(day);
                    const weekKey = weekStart.toISOString().split('T')[0];
                    if (!weeks[weekKey]) weeks[weekKey] = [];
                    weeks[weekKey].push({ day, index });
                });
                
                Object.entries(weeks).forEach(([weekKey, days]) => {
                    const startX = leftMargin + (days[0].index * dayWidth);
                    const barWidth = days.length * dayWidth;
                    
                    svg += `<rect x="${startX}" y="${headerHeight}" width="${barWidth}" height="${svgHeight - headerHeight}" 
                            fill="#f8f8f8" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                });
                
            } else if (timeLevels === 'week-day') {
                // Cada dia tem sua própria barra de fundo
                workingDays.forEach((day, index) => {
                    const startX = leftMargin + (index * dayWidth);
                    
                    svg += `<rect x="${startX}" y="${headerHeight}" width="${dayWidth}" height="${svgHeight - headerHeight}" 
                            fill="#f8f8f8" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                });
            }
            
            return svg;
        }

        // Desenhar cabeçalhos de tempo
        function drawTimeHeaders(workingDays, width, leftMargin, dayWidth) {
            let svg = '<g id="time_headers">';
            const availableWidth = width - leftMargin;
            
            if (timeLevels === 'year-month') {
                svg += drawYearMonthHeaders(workingDays, leftMargin, dayWidth);
            } else if (timeLevels === 'month-week') {
                svg += drawMonthWeekHeaders(workingDays, leftMargin, dayWidth);
            } else if (timeLevels === 'week-day') {
                svg += drawWeekDayHeaders(workingDays, leftMargin, dayWidth);
            }
            
            svg += '</g>';
            return svg;
        }

        // Desenhar cabeçalhos de ano e mês
        function drawYearMonthHeaders(workingDays, leftMargin, dayWidth) {
            let svg = '';
            
            // Agrupar por anos
            const years = {};
            workingDays.forEach((day, index) => {
                const year = day.getFullYear();
                if (!years[year]) years[year] = [];
                years[year].push({ day, index });
            });
            
            // Desenhar anos (nível superior)
            Object.entries(years).forEach(([year, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                
                svg += `<rect x="${startX}" y="0" width="${width}" height="50" 
                        fill="#373737" rx="6" ry="6" stroke="white" stroke-width="4"/>`;
                        
                svg += `<text x="${startX + width/2}" y="35" text-anchor="middle" 
                        font-family="Inter, Arial, sans-serif" font-size="24" font-weight="bold" fill="#FAF9FA">${year}</text>`;
            });
            
            // Agrupar por meses
            const months = {};
            workingDays.forEach((day, index) => {
                const monthKey = `${day.getFullYear()}-${day.getMonth()}`;
                if (!months[monthKey]) months[monthKey] = [];
                months[monthKey].push({ day, index });
            });
            
            // Desenhar meses (nível inferior)
            Object.entries(months).forEach(([monthKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                const monthName = days[0].day.toLocaleDateString('pt-BR', { month: 'long' });
                
                svg += `<rect x="${startX}" y="50" width="${width}" height="50" 
                        fill="#D9D9D9" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                        
                if (width > 50) {
                    svg += `<text x="${startX + width/2}" y="85" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="16" fill="#373737">
                            ${monthName.charAt(0).toUpperCase() + monthName.slice(1)}</text>`;
                } else if (width > 30) {
                    // Usar abreviação para meses pequenos
                    const shortMonth = days[0].day.toLocaleDateString('pt-BR', { month: 'short' });
                    svg += `<text x="${startX + width/2}" y="85" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="14" fill="#373737">
                            ${shortMonth.charAt(0).toUpperCase() + shortMonth.slice(1)}</text>`;
                }
            });
            
            return svg;
        }

        // Desenhar cabeçalhos de mês e semana
        function drawMonthWeekHeaders(workingDays, leftMargin, dayWidth) {
            let svg = '';
            
            // Agrupar por meses
            const months = {};
            workingDays.forEach((day, index) => {
                const monthKey = `${day.getFullYear()}-${day.getMonth()}`;
                if (!months[monthKey]) months[monthKey] = [];
                months[monthKey].push({ day, index });
            });
            
            // Desenhar meses (nível superior)
            Object.entries(months).forEach(([monthKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                const monthName = days[0].day.toLocaleDateString('pt-BR', { month: 'long' });
                
                svg += `<rect x="${startX}" y="0" width="${width}" height="50" 
                        fill="#373737" rx="6" ry="6" stroke="white" stroke-width="4"/>`;
                        
                svg += `<text x="${startX + width/2}" y="35" text-anchor="middle" 
                        font-family="Inter, Arial, sans-serif" font-size="24" font-weight="bold" fill="#FAF9FA">
                        ${monthName.charAt(0).toUpperCase() + monthName.slice(1)}</text>`;
            });
            
            // Agrupar por semanas
            const weeks = {};
            workingDays.forEach((day, index) => {
                const weekStart = getWeekStart(day);
                const weekKey = weekStart.toISOString().split('T')[0];
                if (!weeks[weekKey]) weeks[weekKey] = [];
                weeks[weekKey].push({ day, index });
            });
            
            // Desenhar semanas (nível inferior)  
            Object.entries(weeks).forEach(([weekKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                
                const weekStart = days[0].day;
                const weekEnd = days[days.length - 1].day;
                const startDay = weekStart.getDate();
                const endDay = weekEnd.getDate();
                
                svg += `<rect x="${startX}" y="50" width="${width}" height="50" 
                        fill="#D9D9D9" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                        
                if (width > 40) {
                    svg += `<text x="${startX + width/2}" y="85" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="16" fill="#373737">
                            ${startDay}-${endDay}</text>`;
                }
            });
            
            return svg;
        }

        // Desenhar cabeçalhos de semana e dia
        function drawWeekDayHeaders(workingDays, leftMargin, dayWidth) {
            let svg = '';
            
            // Agrupar por semanas
            const weeks = {};
            workingDays.forEach((day, index) => {
                const weekStart = getWeekStart(day);
                const weekKey = weekStart.toISOString().split('T')[0];
                if (!weeks[weekKey]) weeks[weekKey] = [];
                weeks[weekKey].push({ day, index });
            });
            
            // Desenhar semanas (nível superior)
            Object.entries(weeks).forEach(([weekKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                
                const weekStart = days[0].day;
                const weekEnd = days[days.length - 1].day;
                const startDay = weekStart.getDate();
                const endDay = weekEnd.getDate();
                const monthName = weekStart.toLocaleDateString('pt-BR', { month: 'short' });
                
                svg += `<rect x="${startX}" y="0" width="${width}" height="50" 
                        fill="#373737" rx="6" ry="6" stroke="white" stroke-width="4"/>`;
                        
                svg += `<text x="${startX + width/2}" y="35" text-anchor="middle" 
                        font-family="Inter, Arial, sans-serif" font-size="18" font-weight="bold" fill="#FAF9FA">
                        ${monthName} ${startDay}-${endDay}</text>`;
            });
            
            // Desenhar dias (nível inferior)
            workingDays.forEach((day, index) => {
                const startX = leftMargin + (index * dayWidth);
                const dayNum = day.getDate();
                const dayName = day.toLocaleDateString('pt-BR', { weekday: 'short' });
                
                svg += `<rect x="${startX}" y="50" width="${dayWidth}" height="50" 
                        fill="#D9D9D9" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                        
                if (dayWidth > 25) {
                    svg += `<text x="${startX + dayWidth/2}" y="70" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="12" fill="#373737">${dayName}</text>`;
                    svg += `<text x="${startX + dayWidth/2}" y="90" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="16" font-weight="bold" fill="#373737">${dayNum}</text>`;
                }
            });
            
            return svg;
        }

        // Calcular posição X baseada nos dias úteis
        function calculateX(date, workingDays, dayWidth) {
            const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            for (let i = 0; i < workingDays.length; i++) {
                const workingDate = new Date(workingDays[i].getFullYear(), workingDays[i].getMonth(), workingDays[i].getDate());
                if (workingDate.getTime() === targetDate.getTime()) {
                    return i * dayWidth;
                }
                if (workingDate.getTime() > targetDate.getTime()) {
                    return Math.max(0, i - 1) * dayWidth;
                }
            }
            
            return (workingDays.length - 1) * dayWidth;
        }

        // Função para determinar cor do texto baseada no contraste
        function getContrastColor(hexColor) {
            // Converter hex para RGB
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            
            // Calcular luminância
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Retornar preto ou branco baseado na luminância
            return luminance > 0.5 ? '#000000' : '#FFFFFF';
        }

        // Função para obter etapas na ordem definida pelo usuário
        function getOrderedStages() {
            if (stageOrder.length === 0) {
                return Object.entries(processedData);
            }
            
            const orderedStages = [];
            stageOrder.forEach(stageName => {
                const entry = Object.entries(processedData).find(([key, stage]) => stage.name === stageName);
                if (entry) {
                    orderedStages.push(entry);
                }
            });
            
            // Adicionar qualquer etapa que não esteja na ordem (caso tenham sido adicionadas depois)
            Object.entries(processedData).forEach(entry => {
                if (!orderedStages.find(([key]) => key === entry[0])) {
                    orderedStages.push(entry);
                }
            });
            
            return orderedStages;
        }

        // Função para criar interface de ordenação de etapas
        function createStageOrderInterface() {
            const container = document.getElementById('stageOrderContainer');
            const list = document.getElementById('stageOrderList');
            
            if (Object.keys(processedData).length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            list.innerHTML = '';
            
            // Inicializar ordem se não existir
            if (stageOrder.length === 0) {
                stageOrder = Object.values(processedData).map(stage => stage.name);
            }
            
            stageOrder.forEach((stageName, index) => {
                const item = document.createElement('div');
                item.className = 'stage-order-item';
                item.draggable = true;
                item.dataset.stageName = stageName;
                
                item.innerHTML = `
                    <div>
                        <span class="drag-handle">⋮⋮</span>
                        <span>${stageName}</span>
                    </div>
                `;
                
                // Eventos de drag and drop
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
                
                list.appendChild(item);
            });
        }

        // Handlers para drag and drop
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedElement !== this) {
                const draggedIndex = Array.from(this.parentNode.children).indexOf(draggedElement);
                const targetIndex = Array.from(this.parentNode.children).indexOf(this);
                
                // Reordenar array
                const draggedStage = stageOrder.splice(draggedIndex, 1)[0];
                stageOrder.splice(targetIndex, 0, draggedStage);
                
                // Recriar interface
                createStageOrderInterface();
            }
            
            return false;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedElement = null;
        }

        // Função para resetar ordem das etapas
        function resetStageOrder() {
            stageOrder = Object.values(processedData).map(stage => stage.name);
            createStageOrderInterface();
        }

        // Obter início da semana (segunda-feira)
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Segunda-feira como início
            d.setDate(diff);
            d.setHours(0, 0, 0, 0);
            return d;
        }

        // Sanitizar ID para SVG
        function sanitizeId(text) {
            return text.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
        }

        // Exibir preview
        function displayPreview() {
            const container = document.getElementById('svgContainer');
            container.innerHTML = svgContent;
            document.getElementById('previewSection').classList.add('active');
        }

        // Baixar SVG
        function downloadSVG() {
            if (!svgContent) {
                alert('Primeiro gere o SVG!');
                return;
            }
            
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'timeline_cronograma.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Reset
        function resetAll() {
            csvData = [];
            processedData = [];
            allProjects = [];
            currentProject = 'all';
            svgContent = '';
            stageOrder = [];
            document.getElementById('fileInput').value = '';
            document.getElementById('controlsSection').classList.remove('active');
            document.getElementById('previewSection').classList.remove('active');
            document.getElementById('projectSelector').innerHTML = '<option value="all">Todos os Projetos</option>';
        }
    </script>
</body>
</html>
