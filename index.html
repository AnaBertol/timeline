<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Timeline SVG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #FAF9FA;
            padding: 40px;
            color: #373737;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #6F02FD;
            font-size: 48px;
            font-weight: 300;
            margin-bottom: 40px;
        }

        .upload-section {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 40px;
        }

        .upload-area {
            border: 2px dashed #6F02FD;
            border-radius: 8px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #2C0165;
            background: #f5f3ff;
        }

        .upload-area.drag-over {
            border-color: #2C0165;
            background: #e8e0ff;
        }

        .upload-input {
            display: none;
        }

        .upload-text {
            font-size: 20px;
            color: #373737;
            margin-bottom: 10px;
        }

        .upload-subtext {
            font-size: 14px;
            color: #666;
        }

        .controls-section {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 40px;
            display: none;
        }

        .controls-section.active {
            display: block;
        }

        .control-group {
            margin-bottom: 30px;
        }

        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #373737;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-item {
            flex: 1;
        }

        .date-inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .date-input {
            flex: 1;
        }

        .date-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .dimension-inputs {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .dimension-input {
            flex: 1;
        }

        .dimension-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .toggle-buttons {
            display: flex;
            gap: 5px;
            background: #f0f0f0;
            padding: 3px;
            border-radius: 6px;
            overflow: hidden;
        }

        .toggle-button {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .toggle-button.active {
            background: #6F02FD;
            color: white;
        }

        .button {
            padding: 12px 24px;
            background: #6F02FD;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            margin-right: 10px;
        }

        .button:hover {
            background: #2C0165;
        }

        .button.secondary {
            background: #3570DF;
        }

        .button.secondary:hover {
            background: #2C0165;
        }

        .preview-section {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: none;
            overflow-x: auto;
        }

        .preview-section.active {
            display: block;
        }

        .preview-container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
        }

        #svgPreview {
            max-width: 100%;
            height: auto;
        }

        .project-selector {
            margin-bottom: 20px;
        }

        .project-selector label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #373737;
        }

        .project-selector select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
        }

        .info-message {
            background: #e8e0ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            color: #2C0165;
        }

        select, input[type="date"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }

        .stage-order-item {
            background: #f5f5f5;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .stage-order-item:hover {
            background: #e8e0ff;
        }

        .stage-order-item.dragging {
            opacity: 0.5;
        }

        .drag-handle {
            color: #666;
            margin-right: 10px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Gerador de Timeline SVG</h1>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" class="upload-input" accept=".csv">
                <div class="upload-text">Arraste o arquivo CSV aqui</div>
                <div class="upload-subtext">ou clique para selecionar</div>
            </div>
        </div>

        <div class="controls-section" id="controlsSection">
            <div class="info-message">
                ℹ️ O SVG será otimizado para importação no Figma, com grupos nomeados e estrutura editável.
            </div>

            <div class="control-group">
                <div class="project-selector">
                    <label>Selecione o Projeto:</label>
                    <select id="projectSelector" onchange="filterByProject()">
                        <option value="all">Todos os Projetos</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Período do Cronograma</label>
                <div class="date-inputs">
                    <div class="date-input">
                        <label>Data Inicial:</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="date-input">
                        <label>Data Final:</label>
                        <input type="date" id="endDate">
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Ordem das Etapas</label>
                <div id="stageOrderContainer" style="display: none;">
                    <div id="stageOrderList"></div>
                    <button type="button" class="button secondary" onclick="resetStageOrder()">Restaurar Ordem Original</button>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Configurações de Exibição</label>
                <div class="control-row">
                    <div class="control-item">
                        <label>Níveis de Tempo:</label>
                        <select id="timeLevels" onchange="updateTimeLevels()">
                            <option value="year-month">Anos e Meses</option>
                            <option value="month-week" selected>Meses e Semanas</option>
                            <option value="week-day">Semanas e Dias</option>
                        </select>
                    </div>
                    <div class="control-item">
                        <div class="checkbox-group">
                            <input type="checkbox" id="includeWeekends" onchange="updateWeekendSetting()">
                            <label for="includeWeekends">Incluir finais de semana</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Dimensões do SVG</label>
                <div class="dimension-inputs">
                    <div class="dimension-input">
                        <label>Largura (px):</label>
                        <input type="number" id="svgWidth" value="1920" min="800" max="4000">
                    </div>
                    <div class="dimension-input">
                        <label>Altura da barra (px):</label>
                        <input type="number" id="barHeight" value="28" min="20" max="80">
                    </div>
                    <div class="dimension-input">
                        <label>Largura da área de tarefas (px):</label>
                        <input type="number" id="taskAreaWidth" value="300" min="200" max="600">
                    </div>
                </div>
            </div>

            <button class="button" onclick="generateSVG()">Gerar SVG</button>
            <button class="button secondary" onclick="downloadSVG()">Baixar SVG</button>
            <button class="button secondary" onclick="resetAll()">Novo Arquivo</button>
        </div>

        <div class="preview-section" id="previewSection">
            <h2>Preview do SVG</h2>
            <div class="preview-container" id="svgContainer"></div>
        </div>
    </div>

    <script>
        // Variáveis globais
        let csvData = [];
        let processedData = [];
        let allProjects = [];
        let currentProject = 'all';
        let svgContent = '';
        let timeLevels = 'month-week';
        let includeWeekends = false;
        let stageOrder = [];
        let colorPalette = ['#6F02FD', '#2C0165', '#6CDADE', '#3570DF', '#EDFF19', '#FFA4E8'];
        let groupColors = {};

        // Configurar upload
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Processar arquivo
        function handleFile(file) {
            if (!file.name.endsWith('.csv')) {
                alert('Por favor, selecione um arquivo CSV');
                return;
            }

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    csvData = results.data;
                    processCSVData();
                },
                error: function(error) {
                    alert('Erro ao ler o arquivo: ' + error.message);
                }
            });
        }

        // Processar dados do CSV
        function processCSVData() {
            // Filtrar tarefas válidas
            const validTasks = csvData.filter(row => {
                return row['Due Date'] && row.Task;
            });

            if (validTasks.length === 0) {
                alert('Nenhuma tarefa válida encontrada no arquivo');
                return;
            }

            // Identificar todos os projetos únicos
            allProjects = [...new Set(validTasks.map(task => task.Project || 'Sem Projeto'))];
            
            // Atualizar o seletor de projetos
            const projectSelector = document.getElementById('projectSelector');
            projectSelector.innerHTML = '<option value="all">Todos os Projetos</option>';
            allProjects.forEach(project => {
                const option = document.createElement('option');
                option.value = project;
                option.textContent = project;
                projectSelector.appendChild(option);
            });

            // Processar dados inicialmente com todos os projetos
            processProjectData(validTasks);

            // Mostrar controles
            document.getElementById('controlsSection').classList.add('active');
        }

        // Processar dados de acordo com o projeto selecionado
        function processProjectData(tasks) {
            // Filtrar por projeto se necessário
            let filteredTasks = tasks;
            if (currentProject !== 'all') {
                filteredTasks = tasks.filter(task => task.Project === currentProject);
            }

            // Calcular período real das tarefas (sem ajustes ainda) - USANDO NORMALIZAÇÃO
            let allDates = [];
            filteredTasks.forEach(task => {
                const dueDate = normalizeDate(task['Due Date']);
                let startDate = task.Start ? normalizeDate(task.Start) : null;
                
                if (!startDate || isNaN(startDate)) {
                    startDate = new Date(dueDate);
                    startDate.setDate(startDate.getDate() - 7);
                }
                
                allDates.push(startDate, dueDate);
            });

            const minTaskDate = new Date(Math.min(...allDates));
            const maxTaskDate = new Date(Math.max(...allDates));
            
            // Ajustar período para incluir contexto visual, mas manter referência às datas reais
            const adjustedDates = adjustDateRange(minTaskDate, maxTaskDate);
            
            // Atualizar inputs
            document.getElementById('startDate').value = adjustedDates.start.toISOString().split('T')[0];
            document.getElementById('endDate').value = adjustedDates.end.toISOString().split('T')[0];

            // Processar e organizar dados
            processedData = organizeData(filteredTasks);
            
            // Criar interface de ordenação de etapas
            createStageOrderInterface();
        }

        // Ajustar range de datas baseado no nível (CORRIGIDO)
        function adjustDateRange(minDate, maxDate) {
            const start = new Date(minDate);
            const end = new Date(maxDate);

            // Adicionar margem conservadora primeiro
            start.setDate(start.getDate() - 3);
            end.setDate(end.getDate() + 3);

            // Depois ajustar para boundaries naturais baseado no nível
            switch (timeLevels) {
                case 'year-month':
                    // Ajustar para início/fim do mês mais próximo
                    start.setDate(1);
                    end.setMonth(end.getMonth() + 1, 0);
                    break;
                case 'month-week':
                    // Ajustar para início da semana mais próxima
                    const startWeekDay = start.getDay();
                    const endWeekDay = end.getDay();
                    start.setDate(start.getDate() - (startWeekDay === 0 ? 6 : startWeekDay - 1));
                    end.setDate(end.getDate() + (endWeekDay === 0 ? 0 : 7 - endWeekDay));
                    break;
                case 'week-day':
                    // Já está adequado com a margem de 3 dias
                    break;
            }

            return { start, end };
        }

        // Filtrar por projeto
        function filterByProject() {
            const selector = document.getElementById('projectSelector');
            currentProject = selector.value;
            
            // Reprocessar dados com o filtro
            const validTasks = csvData.filter(row => {
                return row['Due Date'] && row.Task;
            });
            
            processProjectData(validTasks);
        }

        // Atualizar configuração de níveis de tempo
        function updateTimeLevels() {
            timeLevels = document.getElementById('timeLevels').value;
            // Reprocessar dados se já existirem
            if (csvData.length > 0) {
                const validTasks = csvData.filter(row => row['Due Date'] && row.Task);
                processProjectData(validTasks);
            }
        }

        // Atualizar configuração de finais de semana
        function updateWeekendSetting() {
            includeWeekends = document.getElementById('includeWeekends').checked;
        }

        // Organizar dados por grupo e projeto
        function organizeData(tasks) {
            console.log(`📋 DEBUG - Organizando ${tasks.length} tarefas:`);
            
            const organized = {};
            
            tasks.forEach((task, index) => {
                const stage = task['Project Stage'] || 'Sem Estágio';
                
                if (!organized[stage]) {
                    organized[stage] = {
                        name: stage,
                        tasks: []
                    };
                }
                
                // Processar datas usando a função normalizada
                const dueDate = normalizeDate(task['Due Date']);
                let startDate = task.Start ? normalizeDate(task.Start) : null;
                
                if (!startDate || isNaN(startDate)) {
                    startDate = new Date(dueDate);
                    startDate.setDate(startDate.getDate() - 7);
                }
                
                // Log apenas das primeiras 3 tarefas para não poluir o console
                if (index < 3) {
                    console.log(`   Tarefa ${index + 1}: ${task.Task}`);
                    console.log(`      Due Date original: ${task['Due Date']}`);
                    console.log(`      Due Date normalizada: ${dueDate.getFullYear()}-${String(dueDate.getMonth() + 1).padStart(2, '0')}-${String(dueDate.getDate()).padStart(2, '0')}`);
                    if (task.Start) {
                        console.log(`      Start original: ${task.Start}`);
                        console.log(`      Start normalizada: ${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}-${String(startDate.getDate()).padStart(2, '0')}`);
                    }
                }
                
                organized[stage].tasks.push({
                    name: task.Task,
                    start: startDate,
                    end: dueDate,
                    assignee: task.Assignee,
                    status: task.Status,
                    completed: task.Completed === true || task.Completed === 'TRUE',
                    effort: task.Effort
                });
            });

            // Ordenar tarefas por data de início dentro de cada etapa
            Object.values(organized).forEach(stage => {
                stage.tasks.sort((a, b) => a.start - b.start);
            });

            // Atribuir cores às etapas
            let colorIndex = 0;
            Object.keys(organized).forEach(stageKey => {
                groupColors[stageKey] = colorPalette[colorIndex % colorPalette.length];
                colorIndex++;
            });

            return organized;
        }

        // Gerar dias da timeline (CORRIGIDO)
        function generateTimelineDays(startDate, endDate) {
            console.log(`📅 DEBUG - Gerando timeline de dias:`);
            console.log(`   Data inicial: ${startDate.toISOString().split('T')[0]}`);
            console.log(`   Data final: ${endDate.toISOString().split('T')[0]}`);
            console.log(`   Incluir finais de semana: ${includeWeekends}`);
            
            const days = [];
            
            // Usar normalização consistente para evitar problemas de fuso horário
            const currentDate = normalizeDate(startDate);
            const endDateNormalized = normalizeDate(endDate);
            
            let dayCount = 0;
            while (currentDate <= endDateNormalized) {
                const dayOfWeek = currentDate.getDay();
                const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6);
                
                // Incluir o dia se finais de semana estão habilitados OU se não é fim de semana
                if (includeWeekends || !isWeekend) {
                    days.push(new Date(currentDate));
                    dayCount++;
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            console.log(`   Total de dias na timeline: ${days.length}`);
            console.log(`   Primeiros 5 dias:`, days.slice(0, 5).map(d => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`));
            console.log(`   Últimos 5 dias:`, days.slice(-5).map(d => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`));
            
            return days;
        }

        // Gerar SVG
        function generateSVG() {
            console.log(`🚀 DEBUG - Iniciando geração do SVG`);
            
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);
            const svgWidth = parseInt(document.getElementById('svgWidth').value);
            const barHeight = parseInt(document.getElementById('barHeight').value);
            const taskAreaWidth = parseInt(document.getElementById('taskAreaWidth').value);
            
            console.log(`   Configurações:`);
            console.log(`   - Período: ${startDate.toISOString().split('T')[0]} até ${endDate.toISOString().split('T')[0]}`);
            console.log(`   - Nível de tempo: ${timeLevels}`);
            console.log(`   - Largura SVG: ${svgWidth}px`);
            console.log(`   - Área de tarefas: ${taskAreaWidth}px`);
            
            // Gerar timeline de dias baseada na configuração
            const timelineDays = generateTimelineDays(startDate, endDate);
            const totalDays = timelineDays.length;
            const dayWidth = (svgWidth - taskAreaWidth) / totalDays;
            
            console.log(`   - Largura por dia: ${dayWidth}px`);
            console.log(`   - Área disponível para timeline: ${svgWidth - taskAreaWidth}px`);
            
            // Calcular altura total
            let totalTasks = 0;
            Object.values(processedData).forEach(stage => {
                totalTasks += stage.tasks.length;
            });
            
            const headerHeight = 100;
            const groupSpacing = 40;
            const taskSpacing = 2;
            
            // Calcular altura total incluindo listas de tarefas
            let totalHeight = headerHeight;
            Object.values(processedData).forEach(stage => {
                totalHeight += 30; // Título da etapa
                totalHeight += stage.tasks.length * (barHeight + taskSpacing);
                totalHeight += groupSpacing;
            });
            const svgHeight = totalHeight + 50;
            
            // Iniciar SVG
            let svg = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
            
            // Adicionar definições
            svg += '<defs>';
            svg += `<clipPath id="taskTextClip">
                      <rect x="10" y="0" width="${taskAreaWidth - 20}" height="${svgHeight}"/>
                    </clipPath>`;
            svg += '</defs>';
            
            // Background
            svg += `<rect width="${svgWidth}" height="${svgHeight}" fill="#FAF9FA"/>`;
            
            // Desenhar calendário
            svg += '<g id="calendario">';
            svg += drawTimeHeaders(timelineDays, svgWidth, taskAreaWidth, dayWidth);
            svg += '</g>';
            
            // Barras de fundo
            svg += '<g id="background_bars">';
            svg += drawBackgroundBars(timelineDays, svgWidth, taskAreaWidth, dayWidth, svgHeight, headerHeight);
            svg += '</g>';
            
            // Desenhar tarefas na ordem definida pelo usuário
            let yOffset = headerHeight;
            const orderedStages = getOrderedStages();
            
            console.log(`📋 DEBUG - Processando ${orderedStages.length} etapas:`);
            
            orderedStages.forEach(([stageKey, stage]) => {
                console.log(`\n📂 Etapa: ${stage.name} (${stage.tasks.length} tarefas)`);
                
                svg += `<g id="stage_${sanitizeId(stageKey)}">`;
                
                // Título da etapa
                svg += `<text x="20" y="${yOffset}" font-family="Inter, Arial, sans-serif" font-size="16" font-weight="bold" fill="#373737">${stage.name}</text>`;
                yOffset += 20;
                
                // Lista de tarefas à esquerda
                const barsStartY = yOffset;
                svg += `<g id="task_list_${sanitizeId(stageKey)}" clip-path="url(#taskTextClip)">`;
                
                let currentTaskY = barsStartY;
                stage.tasks.forEach((task, index) => {
                    const taskHeight = barHeight;
                    const bgColor = groupColors[stageKey];
                    const textColor = getContrastColor(bgColor);
                    
                    // Calcular raio dos cantos baseado na altura da barra (mesmo que as barras da timeline)
                    const cornerRadius = Math.min(barHeight * 0.2, 6);
                    
                    svg += `<rect x="10" y="${currentTaskY}" width="${taskAreaWidth - 20}" height="${barHeight}" 
                            fill="${bgColor}" rx="${cornerRadius}" ry="${cornerRadius}"/>`;
                    
                    const textY = currentTaskY + (taskHeight / 2) + 6;
                    svg += `<text x="${taskAreaWidth - 15}" y="${textY}" font-family="Inter, Arial, sans-serif" font-size="13" fill="${textColor}" text-anchor="end">`;
                    svg += task.name;
                    svg += '</text>';
                    
                    currentTaskY += taskHeight + taskSpacing;
                });
                svg += '</g>';
                
                // Desenhar barras das tarefas (CORRIGIDO)
                currentTaskY = barsStartY;
                stage.tasks.forEach((task, index) => {
                    console.log(`\n   📊 Tarefa ${index + 1}: ${task.name}`);
                    console.log(`      Data início: ${task.start.toISOString().split('T')[0]}`);
                    console.log(`      Data fim: ${task.end.toISOString().split('T')[0]}`);
                    
                    const taskHeight = barHeight;
                    
                    // CORRIGIDO: Usar a nova função com parâmetro para data final
                    const taskStartX = taskAreaWidth + calculateTaskPosition(task.start, timelineDays, dayWidth, false);
                    const taskEndX = taskAreaWidth + calculateTaskPosition(task.end, timelineDays, dayWidth, true);
                    const taskWidth = Math.max(taskEndX - taskStartX, dayWidth * 0.5); // Mínimo de meio dia
                    
                    console.log(`      Posição X inicial: ${taskStartX}px`);
                    console.log(`      Posição X final: ${taskEndX}px`);
                    console.log(`      Largura da barra: ${taskWidth}px`);
                    
                    // Calcular raio dos cantos baseado na altura da barra
                    const cornerRadius = Math.min(barHeight * 0.2, 6); // 20% da altura ou 6px, o que for menor
                    
                    svg += `<g id="task_bar_${sanitizeId(task.name)}_${index}">`;
                    
                    const opacity = task.completed ? 0.4 : 1;
                    svg += `<rect x="${taskStartX}" y="${currentTaskY}" width="${taskWidth}" height="${barHeight}" 
                            fill="${groupColors[stageKey]}" opacity="${opacity}" rx="${cornerRadius}" ry="${cornerRadius}"/>`;
                    
                    svg += `<!-- Task: ${task.name}, Start: ${task.start.toISOString().split('T')[0]}, End: ${task.end.toISOString().split('T')[0]} -->`;
                    
                    svg += '</g>';
                    currentTaskY += taskHeight + taskSpacing;
                });
                
                svg += '</g>';
                yOffset = currentTaskY + groupSpacing;
            });
            
            svg += '</svg>';
            
            svgContent = svg;
            displayPreview();
            
            console.log(`✅ DEBUG - SVG gerado com sucesso!`);
        }

        // Função auxiliar para normalizar data sem problemas de fuso horário
        function normalizeDate(date) {
            if (typeof date === 'string') {
                // Se é string no formato YYYY-MM-DD, criar data local
                const parts = date.split('-');
                return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
            } else {
                // Se já é objeto Date, criar nova instância para evitar mutação
                return new Date(date.getFullYear(), date.getMonth(), date.getDate());
            }
        }

        // NOVA FUNÇÃO: Calcular posição da tarefa de forma mais precisa
        function calculateTaskPosition(taskDate, timelineDays, dayWidth, isEndDate = false) {
            // Normalizar data da tarefa SEM problemas de fuso horário
            const normalizedTaskDate = normalizeDate(taskDate);
            
            // Se é data final, precisamos encontrar o próximo dia útil na timeline
            if (isEndDate) {
                // Em vez de só adicionar 1 dia, vamos encontrar o próximo dia útil disponível na timeline
                let endDate = new Date(normalizedTaskDate);
                endDate.setDate(endDate.getDate() + 1);
                
                // Se não incluir finais de semana, avançar até o próximo dia útil
                if (!includeWeekends) {
                    while (endDate.getDay() === 0 || endDate.getDay() === 6) {
                        endDate.setDate(endDate.getDate() + 1);
                    }
                }
                
                normalizedTaskDate.setTime(endDate.getTime());
            }
            
            console.log(`🔍 DEBUG - Calculando posição para tarefa:`);
            console.log(`   Data da tarefa original: ${taskDate.toISOString().split('T')[0]}`);
            console.log(`   É data final: ${isEndDate}`);
            console.log(`   Data normalizada: ${normalizedTaskDate.getFullYear()}-${String(normalizedTaskDate.getMonth() + 1).padStart(2, '0')}-${String(normalizedTaskDate.getDate()).padStart(2, '0')}`);
            console.log(`   Timeline tem ${timelineDays.length} dias`);
            console.log(`   Largura do dia: ${dayWidth}px`);
            
            // Procurar a data exata ou a mais próxima
            for (let i = 0; i < timelineDays.length; i++) {
                const timelineDate = normalizeDate(timelineDays[i]);
                
                if (timelineDate.getTime() === normalizedTaskDate.getTime()) {
                    // Data exata encontrada
                    const position = i * dayWidth;
                    console.log(`   ✅ Data exata encontrada no índice ${i}, posição: ${position}px`);
                    return position;
                }
                
                if (timelineDate.getTime() > normalizedTaskDate.getTime()) {
                    // A data da tarefa está entre duas datas da timeline
                    if (i === 0) {
                        // Tarefa antes do início da timeline
                        console.log(`   ⚠️ Tarefa antes do início da timeline, posição: 0px`);
                        return 0;
                    }
                    
                    // Para datas finais que caem entre dias úteis, usar o início do próximo dia útil
                    if (isEndDate) {
                        const position = i * dayWidth;
                        console.log(`   📍 Data final ajustada para próximo dia útil no índice ${i}, posição: ${position}px`);
                        return position;
                    }
                    
                    // Para datas de início, manter a interpolação
                    const prevDate = normalizeDate(timelineDays[i - 1]);
                    
                    const daysDiff = (normalizedTaskDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24);
                    const daysInInterval = (timelineDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24);
                    
                    const interpolationFactor = daysDiff / daysInInterval;
                    const position = ((i - 1) + interpolationFactor) * dayWidth;
                    
                    const prevDateStr = `${prevDate.getFullYear()}-${String(prevDate.getMonth() + 1).padStart(2, '0')}-${String(prevDate.getDate()).padStart(2, '0')}`;
                    const timelineDateStr = `${timelineDate.getFullYear()}-${String(timelineDate.getMonth() + 1).padStart(2, '0')}-${String(timelineDate.getDate()).padStart(2, '0')}`;
                    
                    console.log(`   📍 Interpolando entre ${prevDateStr} e ${timelineDateStr}`);
                    console.log(`   Dias de diferença: ${daysDiff}, Intervalo: ${daysInInterval}, Fator: ${interpolationFactor}`);
                    console.log(`   Posição calculada: ${position}px`);
                    
                    return position;
                }
            }
            
            // Tarefa após o fim da timeline
            const position = (timelineDays.length - 1) * dayWidth;
            console.log(`   ⚠️ Tarefa após o fim da timeline, posição: ${position}px`);
            return position;
        }

        // Desenhar barras de fundo (atualizado para usar a nova lista de dias)
        function drawBackgroundBars(timelineDays, width, leftMargin, dayWidth, svgHeight, headerHeight) {
            let svg = '';
            
            if (timeLevels === 'year-month') {
                const months = {};
                timelineDays.forEach((day, index) => {
                    const monthKey = `${day.getFullYear()}-${day.getMonth()}`;
                    if (!months[monthKey]) months[monthKey] = [];
                    months[monthKey].push({ day, index });
                });
                
                Object.entries(months).forEach(([monthKey, days]) => {
                    const startX = leftMargin + (days[0].index * dayWidth);
                    const barWidth = days.length * dayWidth;
                    
                    svg += `<rect x="${startX}" y="${headerHeight}" width="${barWidth}" height="${svgHeight - headerHeight}" 
                            fill="#f8f8f8" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                });
                
            } else if (timeLevels === 'month-week') {
                const weeks = {};
                timelineDays.forEach((day, index) => {
                    const weekStart = getWeekStart(day);
                    const weekKey = weekStart.toISOString().split('T')[0];
                    if (!weeks[weekKey]) weeks[weekKey] = [];
                    weeks[weekKey].push({ day, index });
                });
                
                Object.entries(weeks).forEach(([weekKey, days]) => {
                    const startX = leftMargin + (days[0].index * dayWidth);
                    const barWidth = days.length * dayWidth;
                    
                    svg += `<rect x="${startX}" y="${headerHeight}" width="${barWidth}" height="${svgHeight - headerHeight}" 
                            fill="#f8f8f8" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                });
                
            } else if (timeLevels === 'week-day') {
                timelineDays.forEach((day, index) => {
                    const startX = leftMargin + (index * dayWidth);
                    
                    svg += `<rect x="${startX}" y="${headerHeight}" width="${dayWidth}" height="${svgHeight - headerHeight}" 
                            fill="#f8f8f8" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                });
            }
            
            return svg;
        }

        // Desenhar cabeçalhos de tempo (atualizado)
        function drawTimeHeaders(timelineDays, width, leftMargin, dayWidth) {
            let svg = '<g id="time_headers">';
            
            if (timeLevels === 'year-month') {
                svg += drawYearMonthHeaders(timelineDays, leftMargin, dayWidth);
            } else if (timeLevels === 'month-week') {
                svg += drawMonthWeekHeaders(timelineDays, leftMargin, dayWidth);
            } else if (timeLevels === 'week-day') {
                svg += drawWeekDayHeaders(timelineDays, leftMargin, dayWidth);
            }
            
            svg += '</g>';
            return svg;
        }

        // Desenhar cabeçalhos de ano e mês (atualizado)
        function drawYearMonthHeaders(timelineDays, leftMargin, dayWidth) {
            let svg = '';
            
            // Agrupar por anos
            const years = {};
            timelineDays.forEach((day, index) => {
                const year = day.getFullYear();
                if (!years[year]) years[year] = [];
                years[year].push({ day, index });
            });
            
            // Desenhar anos
            Object.entries(years).forEach(([year, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                
                svg += `<rect x="${startX}" y="0" width="${width}" height="50" 
                        fill="#373737" rx="6" ry="6" stroke="white" stroke-width="4"/>`;
                        
                svg += `<text x="${startX + width/2}" y="35" text-anchor="middle" 
                        font-family="Inter, Arial, sans-serif" font-size="24" font-weight="bold" fill="#FAF9FA">${year}</text>`;
            });
            
            // Agrupar por meses
            const months = {};
            timelineDays.forEach((day, index) => {
                const monthKey = `${day.getFullYear()}-${day.getMonth()}`;
                if (!months[monthKey]) months[monthKey] = [];
                months[monthKey].push({ day, index });
            });
            
            // Desenhar meses
            Object.entries(months).forEach(([monthKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                const monthName = days[0].day.toLocaleDateString('pt-BR', { month: 'long' });
                
                svg += `<rect x="${startX}" y="50" width="${width}" height="50" 
                        fill="#D9D9D9" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                        
                if (width > 50) {
                    svg += `<text x="${startX + width/2}" y="85" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="16" fill="#373737">
                            ${monthName.charAt(0).toUpperCase() + monthName.slice(1)}</text>`;
                } else if (width > 30) {
                    const shortMonth = days[0].day.toLocaleDateString('pt-BR', { month: 'short' });
                    svg += `<text x="${startX + width/2}" y="85" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="14" fill="#373737">
                            ${shortMonth.charAt(0).toUpperCase() + shortMonth.slice(1)}</text>`;
                }
            });
            
            return svg;
        }

        // Desenhar cabeçalhos de mês e semana (atualizado)
        function drawMonthWeekHeaders(timelineDays, leftMargin, dayWidth) {
            let svg = '';
            
            console.log(`📅 DEBUG - Desenhando cabeçalhos de mês e semana:`);
            
            // Agrupar por meses
            const months = {};
            timelineDays.forEach((day, index) => {
                const monthKey = `${day.getFullYear()}-${day.getMonth()}`;
                if (!months[monthKey]) months[monthKey] = [];
                months[monthKey].push({ day, index });
            });
            
            // Desenhar meses
            Object.entries(months).forEach(([monthKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                const monthName = days[0].day.toLocaleDateString('pt-BR', { month: 'long' });
                
                svg += `<rect x="${startX}" y="0" width="${width}" height="50" 
                        fill="#373737" rx="6" ry="6" stroke="white" stroke-width="4"/>`;
                        
                svg += `<text x="${startX + width/2}" y="35" text-anchor="middle" 
                        font-family="Inter, Arial, sans-serif" font-size="24" font-weight="bold" fill="#FAF9FA">
                        ${monthName.charAt(0).toUpperCase() + monthName.slice(1)}</text>`;
            });
            
            // Agrupar por semanas
            const weeks = {};
            timelineDays.forEach((day, index) => {
                const weekStart = getWeekStart(day);
                const weekKey = weekStart.toISOString().split('T')[0];
                if (!weeks[weekKey]) weeks[weekKey] = [];
                weeks[weekKey].push({ day, index });
            });
            
            console.log(`   Total de semanas encontradas: ${Object.keys(weeks).length}`);
            
            // Desenhar semanas
            Object.entries(weeks).forEach(([weekKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                
                const weekStart = days[0].day;
                const weekEnd = days[days.length - 1].day;
                const startDay = weekStart.getDate();
                const endDay = weekEnd.getDate();
                
                // Log das primeiras 3 semanas para debug
                const weekIndex = Object.keys(weeks).indexOf(weekKey);
                if (weekIndex < 3) {
                    console.log(`   Semana ${weekIndex + 1}: ${startDay}-${endDay}`);
                    console.log(`      Início real: ${weekStart.getFullYear()}-${String(weekStart.getMonth() + 1).padStart(2, '0')}-${String(weekStart.getDate()).padStart(2, '0')}`);
                    console.log(`      Fim real: ${weekEnd.getFullYear()}-${String(weekEnd.getMonth() + 1).padStart(2, '0')}-${String(weekEnd.getDate()).padStart(2, '0')}`);
                    console.log(`      Posição X: ${startX}px, Largura: ${width}px`);
                    console.log(`      Dias na semana: ${days.length}`);
                }
                
                svg += `<rect x="${startX}" y="50" width="${width}" height="50" 
                        fill="#D9D9D9" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                        
                if (width > 40) {
                    svg += `<text x="${startX + width/2}" y="85" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="16" fill="#373737">
                            ${startDay}-${endDay}</text>`;
                }
            });
            
            return svg;
        }

        // Desenhar cabeçalhos de semana e dia (atualizado)
        function drawWeekDayHeaders(timelineDays, leftMargin, dayWidth) {
            let svg = '';
            
            // Agrupar por semanas
            const weeks = {};
            timelineDays.forEach((day, index) => {
                const weekStart = getWeekStart(day);
                const weekKey = weekStart.toISOString().split('T')[0];
                if (!weeks[weekKey]) weeks[weekKey] = [];
                weeks[weekKey].push({ day, index });
            });
            
            // Desenhar semanas
            Object.entries(weeks).forEach(([weekKey, days]) => {
                const startX = leftMargin + (days[0].index * dayWidth);
                const width = days.length * dayWidth;
                
                const weekStart = days[0].day;
                const weekEnd = days[days.length - 1].day;
                const startDay = weekStart.getDate();
                const endDay = weekEnd.getDate();
                const monthName = weekStart.toLocaleDateString('pt-BR', { month: 'short' });
                
                svg += `<rect x="${startX}" y="0" width="${width}" height="50" 
                        fill="#373737" rx="6" ry="6" stroke="white" stroke-width="4"/>`;
                        
                svg += `<text x="${startX + width/2}" y="35" text-anchor="middle" 
                        font-family="Inter, Arial, sans-serif" font-size="18" font-weight="bold" fill="#FAF9FA">
                        ${monthName} ${startDay}-${endDay}</text>`;
            });
            
            // Desenhar dias
            timelineDays.forEach((day, index) => {
                const startX = leftMargin + (index * dayWidth);
                const dayNum = day.getDate();
                const dayName = day.toLocaleDateString('pt-BR', { weekday: 'short' });
                
                svg += `<rect x="${startX}" y="50" width="${dayWidth}" height="50" 
                        fill="#D9D9D9" rx="4" ry="4" stroke="white" stroke-width="4"/>`;
                        
                if (dayWidth > 25) {
                    svg += `<text x="${startX + dayWidth/2}" y="70" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="12" fill="#373737">${dayName}</text>`;
                    svg += `<text x="${startX + dayWidth/2}" y="90" text-anchor="middle" 
                            font-family="Inter, Arial, sans-serif" font-size="16" font-weight="bold" fill="#373737">${dayNum}</text>`;
                }
            });
            
            return svg;
        }

        // Função para determinar cor do texto baseada no contraste
        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            return luminance > 0.5 ? '#000000' : '#FFFFFF';
        }

        // Função para obter etapas na ordem definida pelo usuário
        function getOrderedStages() {
            if (stageOrder.length === 0) {
                return Object.entries(processedData);
            }
            
            const orderedStages = [];
            stageOrder.forEach(stageName => {
                const entry = Object.entries(processedData).find(([key, stage]) => stage.name === stageName);
                if (entry) {
                    orderedStages.push(entry);
                }
            });
            
            Object.entries(processedData).forEach(entry => {
                if (!orderedStages.find(([key]) => key === entry[0])) {
                    orderedStages.push(entry);
                }
            });
            
            return orderedStages;
        }

        // Função para criar interface de ordenação de etapas
        function createStageOrderInterface() {
            const container = document.getElementById('stageOrderContainer');
            const list = document.getElementById('stageOrderList');
            
            if (Object.keys(processedData).length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            list.innerHTML = '';
            
            if (stageOrder.length === 0) {
                stageOrder = Object.values(processedData).map(stage => stage.name);
            }
            
            stageOrder.forEach((stageName, index) => {
                const item = document.createElement('div');
                item.className = 'stage-order-item';
                item.draggable = true;
                item.dataset.stageName = stageName;
                
                item.innerHTML = `
                    <div>
                        <span class="drag-handle">⋮⋮</span>
                        <span>${stageName}</span>
                    </div>
                `;
                
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
                
                list.appendChild(item);
            });
        }

        // Handlers para drag and drop
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedElement !== this) {
                const draggedIndex = Array.from(this.parentNode.children).indexOf(draggedElement);
                const targetIndex = Array.from(this.parentNode.children).indexOf(this);
                
                const draggedStage = stageOrder.splice(draggedIndex, 1)[0];
                stageOrder.splice(targetIndex, 0, draggedStage);
                
                createStageOrderInterface();
            }
            
            return false;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedElement = null;
        }

        // Função para resetar ordem das etapas
        function resetStageOrder() {
            stageOrder = Object.values(processedData).map(stage => stage.name);
            createStageOrderInterface();
        }

        // Obter início da semana (segunda-feira)
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            d.setDate(diff);
            d.setHours(0, 0, 0, 0);
            return d;
        }

        // Sanitizar ID para SVG
        function sanitizeId(text) {
            return text.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
        }

        // Exibir preview
        function displayPreview() {
            const container = document.getElementById('svgContainer');
            container.innerHTML = svgContent;
            document.getElementById('previewSection').classList.add('active');
        }

        // Baixar SVG
        function downloadSVG() {
            if (!svgContent) {
                alert('Primeiro gere o SVG!');
                return;
            }
            
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'timeline_cronograma.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Reset
        function resetAll() {
            csvData = [];
            processedData = [];
            allProjects = [];
            currentProject = 'all';
            svgContent = '';
            stageOrder = [];
            document.getElementById('fileInput').value = '';
            document.getElementById('controlsSection').classList.remove('active');
            document.getElementById('previewSection').classList.remove('active');
            document.getElementById('projectSelector').innerHTML = '<option value="all">Todos os Projetos</option>';
        }
    </script>
</body>
</html>
